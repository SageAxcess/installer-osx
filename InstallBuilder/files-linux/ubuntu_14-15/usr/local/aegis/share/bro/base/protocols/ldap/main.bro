##! Implements base functionality for LDAP analysis.
##! Generates the Ldap.log file.

# Generated by binpac_quickstart

module Ldap;

export {
	redef enum Log::ID += { LOG, Z_LOG };

	type Info: record {
		## Timestamp for when the event happened.
		ts:     time    &log;
		## Unique ID for the connection.
		uid:    string  &log;
		## The connection's 4-tuple of endpoint addresses/ports.
		id:     conn_id &log;
		
		## Message
		message: string  &log;
		## User
		user: string  &log &default="<unknown>";
                ## Request base object
		base: string  &log &default="";
		## Result
		resultCode: count &log &default=0;

		local_user: string  &log &default="";
		process: string  &log &default="";
	};

	## Event that can be handled to access the LDAP record as it is sent on
	## to the loggin framework.
	global log_ldap: event(rec: Info);
}

const ports = { 389/tcp };

redef record connection += {
	ldap: Ldap::Info &optional;
};

redef likely_server_ports += { ports };

redef record LogZMQ::Info += {
	ldap: Info &log &optional;
};

function write_log(info: Info)
	{
        Log::write(Ldap::LOG, info);

#	when ( local src_host = lookup_addr(info$id$orig_h) )
#		{
		local s: LogZMQ::Info = [
                        $ptype="ldap", $is_proto=T, $ts=info$ts, $uid=info$uid,
                        $username=info$local_user, $process=info$process
                ];

		s$ldap = info;

		Log::write(Ldap::Z_LOG, s);
#		}
	}

event bro_init() &priority=5
	{
	Log::create_stream(Ldap::LOG, [$columns=Info, $ev=log_ldap, $path="ldap"]);

	Log::create_stream(Ldap::Z_LOG, [$columns=LogZMQ::Info]);
        Log::remove_default_filter(Ldap::Z_LOG);
	local filter: Log::Filter = [$name="zmq", $writer=Log::WRITER_ZMQ];
	Log::add_filter(Ldap::Z_LOG, filter);

	Analyzer::register_for_ports(Analyzer::ANALYZER_LDAP, ports);
	}

event ldap_message(c: connection, message: string)
	{
		if ( ! c?$ldap )
		{
		        if( !c?$conn ) {
		            local x: Conn::Info;
	        	    c$conn = x;
		        }
			c$conn$service="ldap";

			local s: Info;
			c$ldap = s;
                        c$ldap$user="unknown";

			c$ldap$local_user=c?$local_user ? c$local_user : "";
			c$ldap$process=c?$process ? c$process : "";
		}

		c$ldap$message = message;
		c$ldap$resultCode = 0;
	}

event ldap_bind(c: connection, user: string)
	{
		if ( ! c?$ldap )
		{
		        if( !c?$conn ) {
		            local x: Conn::Info;
	        	    c$conn = x;
		        }
			c$conn$service="ldap";

			local s: Info;
			c$ldap = s;
                        c$ldap$user="unknown";

			c$ldap$local_user=c?$local_user ? c$local_user : "";
			c$ldap$process=c?$process ? c$process : "";
		}

		c$ldap$user = user;
	}

event ldap_search(c: connection, base: string)
	{
		if ( ! c?$ldap )
		{
		        if( !c?$conn ) {
		            local x: Conn::Info;
	        	    c$conn = x;
		        }
			c$conn$service="ldap";

			local s: Info;
			c$ldap = s;
                        c$ldap$user="unknown";

			c$ldap$local_user=c?$local_user ? c$local_user : "";
			c$ldap$process=c?$process ? c$process : "";
		}

		c$ldap$base = base;
	}

event ldap_response(c: connection, message: string, resultCode: count)
	{
		if ( ! c?$ldap )
		{
		        if( !c?$conn ) {
		            local x: Conn::Info;
	        	    c$conn = x;
		        }
			c$conn$service="ldap";

			local s: Info;
			c$ldap = s;
                        c$ldap$user="unknown";

			c$ldap$local_user=c?$local_user ? c$local_user : "";
			c$ldap$process=c?$process ? c$process : "";
		}

		c$ldap$ts=network_time();
		c$ldap$uid=c$uid;
		c$ldap$id=c$id;

		c$ldap$resultCode = resultCode;

		write_log(c$ldap);
	}
