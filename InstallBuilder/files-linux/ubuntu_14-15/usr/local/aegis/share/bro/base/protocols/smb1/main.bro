##! Implements base functionality for SMB1 analysis.
##! Generates the smb1.log file.

@load base/frameworks/logging
@load base/frameworks/notice

# Generated by binpac_quickstart

module SMB1;

export {
	redef enum Log::ID += { LOG, Z_LOG };

	type Info: record {
		## Timestamp for when the event happened.
		ts	: time		&log;
		## Unique ID for the connection.
		uid	: string	&log;
		## The connection's 4-tuple of endpoint addresses/ports.
		id	: conn_id	&log;
		## Username
		user    : string	&log &default="<unknown>";
		## Share
		share	: string	&log;
		## Filename
		filename: string	&log;
		## Filesize
		filesize: int		&log;
		## Action
		action: string		&log &default="unknown";

		local_user: string	&log &default="";
		process   : string	&log &default="";

		userSet: bool &default=F;
		sessionId : string &log;
	};

        type SmbFile: record {
                fileId: string;
                filename: string;
                operation: string;
                op_bytes: count;
		filesize: count;
        };

	## Event that can be handled to access the SageAxcessSMB record as it is sent on
	## to the loggin framework.
	global log_smb1: event(rec: Info);
}

const ports = { 445/tcp, 138/tcp, 139/tcp };

redef record connection += {
	smb1: SMB1::Info &optional;
};

redef record LogZMQ::Info += {
	smb: Info &log &optional;
};

#TODO: hashmap for files by fileid
global smb_files: table[string] of SmbFile &read_expire=5mins;
# Hash of usernames by session id
global smb_sessions: table[string] of string &read_expire=5mins;
# Hash of Kerberos authentications by host_host pair
global krb_sessions: table[string] of string &read_expire=5mins;

function write_log(info: Info)
	{
        Log::write(SMB1::LOG, info);

#	when ( local src_host = lookup_addr(info$id$orig_h) )
#		{
		local s: LogZMQ::Info = [$ptype="smb", $is_proto=T, $uid=info$uid, $ts=info$ts, $username=info$local_user, $process=info$process];

		s$smb = info;

		Log::write(SMB1::Z_LOG, s);
#		}
	}

event bro_init() &priority=5
	{
	Log::create_stream(SMB1::LOG, [$columns=Info, $ev=log_smb1, $path="smb"]);

	Log::create_stream(SMB1::Z_LOG, [$columns=LogZMQ::Info]);
        Log::remove_default_filter(SMB1::Z_LOG);
	local filter: Log::Filter = [$name="zmq", $writer=Log::WRITER_ZMQ];
	Log::add_filter(SMB1::Z_LOG, filter);

	Analyzer::register_for_ports(Analyzer::ANALYZER_SMB1, ports);
	}

event smb1_message(c: connection, is_orig: bool, cmd: count)
	{

	if ( ! c?$smb1 )
		{
		        if( !c?$conn ) {
		            local x: Conn::Info;
	        	    c$conn = x;
		        }
			c$conn$service="smb";

			local s: Info;
			c$smb1 = s;

			c$smb1$local_user=c?$local_user ? c$local_user : "";
			c$smb1$process=c?$process ? c$process : "";
		}
	}
event smb1_tree_connect(c: connection, is_orig: bool, path: string)
	{
		c$smb1$share = path; #TODO: store treeId and path to hash
	}
event smb1_create(c: connection, is_orig: bool, mid: count, name: string)
	{
		c$smb1$ts=network_time();
		c$smb1$uid=c$uid;
		c$smb1$id=c$id;

		c$smb1$filename = name; #TODO: store mid and path to hash
	}
event smb1_create_resp(c: connection, is_orig: bool, mid: count, size: count)
	{
		c$smb1$filesize = size; #TODO: use mid

		if ( ! c$smb1?$filename ) {
			return;
		}

		if(|c$smb1$filename|==0) {
			return;
		}
		write_log(c$smb1);
	}

event smb1_unknown(c: connection, is_orig: bool, msg: string)
	{
	}

event ntlm_authenticate(c: connection, request: NTLM::Authenticate) &priority=5
	{
	if ( c?$smb1 )
		{
			local u: string;
			u = "";
			if ( request?$domain_name )
				u = u + "\\\\" + request$domain_name + "\\";
			if ( request?$user_name )
				u = u + request$user_name;
			else
				u = request$workstation + "$";

			print fmt("ntlm authentication detected, username=%s, session=%s", u, c$smb1?$sessionId ? c$smb1$sessionId : "unknown");

			c$smb1$user = u;
			c$smb1$userSet = T;

			if(c$smb1?$sessionId)
				smb_sessions[c$smb1$sessionId]=u;
		}
	}

event krb_as_request(c: connection, msg: KRB::KDC_Request) &priority=5
	{
	local key: string;
	local u: string;
	u = fmt("%s/%s", msg$client_name, msg$service_realm);
	key = fmt("%s_%s", c$id$orig_h, c$id$resp_h);

#	print fmt("krb authentication detected, username=%s, src=%s, key=%s", u, c$uid, key);

	krb_sessions[key] = u;

	if ( c?$smb1 )
		{
		c$smb1$user = u;
		c$smb1$userSet = T;

		if(c$smb1?$sessionId)
			smb_sessions[c$smb1$sessionId]=u;
		}
	}


event smb2_message(c: connection, sessionId: string, is_orig: bool, cmd: count)
	{
	if ( ! c?$smb1 )
		{
		        if( !c?$conn ) {
		            local x: Conn::Info;
	        	    c$conn = x;
		        }
			c$conn$service="smb";

			local s: Info;
			c$smb1 = s;

			c$smb1$userSet = F;
			c$smb1$local_user=c?$local_user ? c$local_user : "";
			c$smb1$process=c?$process ? c$process : "";
		}

		local key: string;
		key = fmt("%s_%s", c$id$orig_h, c$id$resp_h);
		if(key in krb_sessions)
		{
			c$smb1$userSet = T;
			c$smb1$user = krb_sessions[key];
		}

		if(sessionId != "")
		{
			if(! c$smb1?$sessionId)
				c$smb1$sessionId = sessionId;

			if(! c$smb1$userSet)
			{
				if (sessionId in smb_sessions)
				{
					c$smb1$user=smb_sessions[sessionId];
					if (c$smb1?$user)
						c$smb1$userSet = T;
				} else {
				}
			}
			else
			{
				smb_sessions[sessionId]=c$smb1$user;
			}
		}
	}

event smb2_tree_connect(c: connection, sessionId: string, is_orig: bool, path: string)
	{
		if(! c$smb1?$sessionId && sessionId != "")
			c$smb1$sessionId = sessionId;

		c$smb1$share = path; #TODO: store treeId and path to hash
	}

event smb2_create(c: connection, sessionId: string, is_orig: bool, name: string )
	{
		if(! c$smb1?$sessionId && sessionId != "")
			c$smb1$sessionId = sessionId;

		c$smb1$ts=network_time();
		c$smb1$uid=c$uid;
		c$smb1$id=c$id;

		c$smb1$filename = name; #TODO: store mid and path to hash
	}

event smb2_create_resp(c: connection, sessionId: string, is_orig: bool, status: count, size: count, fileid: string )
	{
		if(! c$smb1?$sessionId && sessionId != "")
			c$smb1$sessionId = sessionId;

		c$smb1$filesize = size; #TODO: use mid

		if ( ! c$smb1?$filename ) {
			return;
		}

		if(|c$smb1$filename|==0) {
			return;
		}

		if(status==0) {
			local s: SMB1::SmbFile;

			s$fileId = fileid;
			s$filename = c$smb1$filename;
			s$filesize = size;
			s$operation = "";
			s$op_bytes = 0;

			smb_files[fileid] = s;
		} else {
			c$smb1$action = fmt("open failed 0x%x08x", status);
			write_log(c$smb1);
		}
	}

event smb2_set_info(c: connection, sessionId: string, file_id: string, info_type: count, info_class: count)
	{
		if(! c$smb1?$sessionId && sessionId != "")
			c$smb1$sessionId = sessionId;

		if( file_id in smb_files && info_type==1 && info_class==13 )
		{
			smb_files[file_id]$operation = "delete";
		}
	}

event smb2_read(c: connection, sessionId: string, file_id: string, length: count)
	{
		if(! c$smb1?$sessionId && sessionId != "")
			c$smb1$sessionId = sessionId;

		if( file_id in smb_files )
		{
			smb_files[file_id]$operation = "read";
			smb_files[file_id]$op_bytes += length;
		}
	}

event smb2_write(c: connection, sessionId: string, file_id: string, length: count)
	{
		if(! c$smb1?$sessionId && sessionId != "")
			c$smb1$sessionId = sessionId;

		if( file_id in smb_files )
		{
			smb_files[file_id]$operation = "write";
			smb_files[file_id]$op_bytes += length;
		}
	}

event smb2_find(c: connection, sessionId: string, file_id: string)
	{
		if(! c$smb1?$sessionId && sessionId != "")
			c$smb1$sessionId = sessionId;

		if( file_id in smb_files )
		{
			smb_files[file_id]$operation = "list";
		}
	}

event smb2_close(c: connection, sessionId: string, file_id: string)
	{
		if(! c$smb1?$sessionId && sessionId != "")
			c$smb1$sessionId = sessionId;

		if( file_id in smb_files )
		{
			c$smb1$action = smb_files[file_id]$operation;
			c$smb1$filename = smb_files[file_id]$filename;
			c$smb1$filesize = smb_files[file_id]$filesize == 0 ? smb_files[file_id]$op_bytes : smb_files[file_id]$filesize;

			write_log(c$smb1);
			delete smb_files[file_id];
		}
	}


event smb2_unknown(c: connection, sessionId: string, is_orig: bool, msg: string )
	{
	}
