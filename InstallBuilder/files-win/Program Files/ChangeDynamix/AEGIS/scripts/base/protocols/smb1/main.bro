##! Implements base functionality for SMB1 analysis.
##! Generates the smb1.log file.

@load base/frameworks/logging
@load base/frameworks/notice

# Generated by binpac_quickstart

module SMB1;

export {
	redef enum Log::ID += { LOG, Z_LOG };

	type Info: record {
		## Timestamp for when the event happened.
		ts	: time		&log;
		## Unique ID for the connection.
		uid	: string	&log;
		## The connection's 4-tuple of endpoint addresses/ports.
		id	: conn_id	&log;
		## Username
		user    : string	&log &default="<unknown>";
		## Share
		share	: string	&log;
		## Filename
		filename: string	&log;
		## Filesize
		filesize: int		&log;
		## Action
		action: string		&log &default="unknown";

		local_user: string	&log &default="";
		process   : string	&log &default="";
	};

        type SmbFile: record {
                fileId: string;
                filename: string;
                operation: string;
                op_bytes: count;
		filesize: count;
        };

	## Event that can be handled to access the SageAxcessSMB record as it is sent on
	## to the loggin framework.
	global log_smb1: event(rec: Info);
}

const ports = { 445/tcp, 138/tcp, 139/tcp };

redef record connection += {
	smb1: SMB1::Info &optional;
};

redef record LogZMQ::Info += {
	smb: Info &log &optional;
};

#TODO: hashmap for files by fileid
global smb_files: table[string] of SmbFile &read_expire=5mins;

function write_log(info: Info)
	{
        Log::write(SMB1::LOG, info);

#	when ( local src_host = lookup_addr(info$id$orig_h) )
#		{
		local s: LogZMQ::Info = [$ptype="smb", $is_proto=T, $uid=info$uid, $ts=info$ts, $username=info$local_user, $process=info$process];

		s$smb = info;

		Log::write(SMB1::Z_LOG, s);
#		}
	}

event bro_init() &priority=5
	{
	Log::create_stream(SMB1::LOG, [$columns=Info, $ev=log_smb1, $path="smb"]);

	Log::create_stream(SMB1::Z_LOG, [$columns=LogZMQ::Info]);
        Log::remove_default_filter(SMB1::Z_LOG);
	local filter: Log::Filter = [$name="zmq", $writer=Log::WRITER_ZMQ];
	Log::add_filter(SMB1::Z_LOG, filter);

	Analyzer::register_for_ports(Analyzer::ANALYZER_SMB1, ports);
	}

event smb1_message(c: connection, is_orig: bool, cmd: count)
	{

	if ( ! c?$smb1 )
		{
		        if( !c?$conn ) {
		            local x: Conn::Info;
	        	    c$conn = x;
		        }
			c$conn$service="smb";

			local s: Info;
			c$smb1 = s;

			c$smb1$local_user=c?$local_user ? c$local_user : "";
			c$smb1$process=c?$process ? c$process : "";
		}
	}
event smb1_tree_connect(c: connection, is_orig: bool, path: string)
	{
		c$smb1$share = path; #TODO: store treeId and path to hash
	}
event smb1_create(c: connection, is_orig: bool, mid: count, name: string)
	{
		c$smb1$ts=network_time();
		c$smb1$uid=c$uid;
		c$smb1$id=c$id;

		c$smb1$filename = name; #TODO: store mid and path to hash
	}
event smb1_create_resp(c: connection, is_orig: bool, mid: count, size: count)
	{
		c$smb1$filesize = size; #TODO: use mid

		if ( ! c$smb1?$filename ) {
			return;
		}

		if(|c$smb1$filename|==0) {
			return;
		}
		write_log(c$smb1);
	}

event smb1_unknown(c: connection, is_orig: bool, msg: string)
	{
	}

event smb2_message(c: connection, is_orig: bool, cmd: count)
	{

	if ( ! c?$smb1 )
		{
		        if( !c?$conn ) {
		            local x: Conn::Info;
	        	    c$conn = x;
		        }
			c$conn$service="smb";

			local s: Info;
			c$smb1 = s;

			c$smb1$local_user=c?$local_user ? c$local_user : "";
			c$smb1$process=c?$process ? c$process : "";
		}
	}

event smb2_tree_connect(c: connection, is_orig: bool, path: string)
	{
		c$smb1$share = path; #TODO: store treeId and path to hash
	}

event smb2_create(c: connection, is_orig: bool, name: string )
	{
		c$smb1$ts=network_time();
		c$smb1$uid=c$uid;
		c$smb1$id=c$id;

		c$smb1$filename = name; #TODO: store mid and path to hash
	}

event smb2_create_resp(c: connection, is_orig: bool, size: count, fileid: string )
	{
		c$smb1$filesize = size; #TODO: use mid

		if ( ! c$smb1?$filename ) {
			return;
		}

		if(|c$smb1$filename|==0) {
			return;
		}
#		write_log(c$smb1);
		
		local s: SMB1::SmbFile;

		s$fileId = fileid;
		s$filename = c$smb1$filename;
		s$filesize = size;
		s$operation = "";
		s$op_bytes = 0;

		smb_files[fileid] = s;
	}

event smb2_set_info(c: connection, file_id: string, info_type: count, info_class: count)
	{
		if( file_id in smb_files && info_type==1 && info_class==13 )
		{
			smb_files[file_id]$operation = "delete";
		}
	}

event smb2_read(c: connection, file_id: string, length: count)
	{
		if( file_id in smb_files )
		{
			smb_files[file_id]$operation = "read";
			smb_files[file_id]$op_bytes += length;
		}
	}

event smb2_write(c: connection, file_id: string, length: count)
	{
		if( file_id in smb_files )
		{
			smb_files[file_id]$operation = "write";
			smb_files[file_id]$op_bytes += length;
		}
	}

event smb2_find(c: connection, file_id: string)
	{
		if( file_id in smb_files )
		{
			smb_files[file_id]$operation = "list";
		}
	}

event smb2_close(c: connection, file_id: string)
	{
		if( file_id in smb_files )
		{
			c$smb1$action = smb_files[file_id]$operation;
			c$smb1$filename = smb_files[file_id]$filename;
			c$smb1$filesize = smb_files[file_id]$filesize == 0 ? smb_files[file_id]$op_bytes : smb_files[file_id]$filesize;

			write_log(c$smb1);
			delete smb_files[file_id];
		}
	}


event smb2_unknown(c: connection, is_orig: bool, msg: string )
	{
	}
